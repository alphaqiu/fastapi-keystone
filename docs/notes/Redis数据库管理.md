Redis 中的 **`db`（数据库）** 是一个逻辑上的隔离空间，允许你在同一个 Redis 实例中存储多个独立的数据集合。它是 Redis 提供的一种简单的多租户机制。

---

## 🧩 一、Redis `db` 的基本概念

- Redis 默认支持 **16 个数据库（编号从 0 到 15）**。
- 每个数据库之间是相互隔离的，即在 `db 0` 中设置的键不会出现在 `db 1` 中。
- 你可以通过 `SELECT <db_number>` 命令切换当前使用的数据库。
- 数据库数量可以在 `redis.conf` 配置文件中通过 `databases` 参数修改。

```bash
# redis.conf 示例
databases 16
```

---

## 🔍 二、使用方式（以 `redis-cli` 为例）

```bash
# 进入 db 0
127.0.0.1:6379> SELECT 0
OK

# 存储数据
127.0.0.1:6379[0]> SET key1 "value1"
OK

# 切换到 db 1
127.0.0.1:6379[0]> SELECT 1
OK

# 此时 key1 并不存在于 db 1 中
127.0.0.1:6379[1]> GET key1
(nil)
```

---

## 🎯 三、Redis `db` 的常见用途

| 使用场景 | 描述 |
|----------|------|
| **开发/测试/生产环境隔离** | 不同环境使用不同的 db，避免数据污染（如：db 0=dev, db 1=test, db 2=prod） |
| **微服务架构下的模块隔离** | 每个服务或模块使用自己的 db，便于管理和维护 |
| **临时调试数据存放** | 调试时可以使用某个 db 作为临时存储，不影响主业务数据 |
| **快速原型开发** | 小型项目中可省去部署多个 Redis 实例的成本，用 db 来模拟“多实例” |
| **缓存 + 会话共存** | 例如：db 0 用于缓存，db 1 用于 Session 存储 |

---

## ⚠️ 四、注意事项

虽然 `db` 看起来很方便，但在生产环境中应谨慎使用：

### ❌ 不适合做严格隔离：
- `db` 只是逻辑隔离，并不提供安全隔离（比如权限控制、资源限制等）。
- 所有 db 共享同一个内存池和性能瓶颈。

### ❌ 不支持集群模式下的 `SELECT`：
- 在 Redis Cluster 模式下，`SELECT` 命令被禁用，只能使用默认的 `db 0`。
- 所以如果你计划使用 Redis 集群，应避免依赖 `db`。

### ✅ 推荐替代方案：
- 如果需要严格的隔离性，建议使用多个 Redis 实例或命名空间（如前缀 `user:`, `order:` 等）代替 `db`。

---

## 💡 五、Python 示例（使用 `redis-py`）

```python
import redis

# 连接 db 0
r0 = redis.Redis(host='localhost', port=6379, db=0)
r0.set('key', 'value_from_db0')

# 连接 db 1
r1 = redis.Redis(host='localhost', port=6379, db=1)
print(r1.get('key'))  # 输出: None，因为 db1 中没有这个 key
```

---

## ✅ 总结

| 特点 | 内容 |
|------|------|
| 类型 | 逻辑数据库 |
| 数量 | 默认 16 个（0 ~ 15） |
| 切换命令 | `SELECT <db_number>` |
| 适用场景 | 开发测试、小型项目、模块隔离 |
| 注意事项 | 不适合生产级隔离、不支持 Redis Cluster |

---

Redis 的客户端和服务器之间通过 Redis 序列化协议（RESP，Redis Serialization Protocol）进行通信。随着 Redis 6.0 的发布，引入了 RESP3 协议版本，旨在改进与扩展 RESP2 的功能。

### RESP2 vs RESP3 主要区别

1. **数据类型支持**
   - **RESP2** 支持简单的字符串、错误、整数、批量字符串（Bulk Strings）、数组等基本数据类型。
   - **RESP3** 增加了对更多数据类型的直接支持，包括但不限于：双精度浮点数(Double)、布尔值(Boolean)、大整数(Long Long)、映射(Map)、集合(Set)、属性(Attribute)等。这使得客户端可以直接解析这些类型的数据，而不需要手动转换。

2. **错误处理**
   - 在 **RESP2** 中，所有的错误都以相同的格式返回，并且没有明确的分类。
   - **RESP3** 引入了更细粒度的错误类型，允许客户端根据错误的具体类型采取不同的处理策略。

3. **属性（Attributes）**
   - **RESP3** 引入了一个新的“属性”数据类型，可以为响应添加元数据。例如，在命令的结果中包含额外的信息而不影响结果本身。

4. **向后兼容性**
   - **RESP3** 设计时考虑到了向后兼容性问题，即它能够在同一个连接上同时支持 RESP2 和 RESP3。这意味着如果客户端不支持 RESP3 或者请求使用 RESP2，则服务器会自动降级到 RESP2 模式。

5. **性能**
   - 理论上，由于 RESP3 提供了更多的原生数据类型支持，可能会减少某些情况下需要进行的类型转换，从而提高性能。然而，在大多数实际应用场景中，这种差异可能是微乎其微的。

6. **命令回复的变化**
   - 随着新数据类型的引入，一些 Redis 命令的输出可能在 RESP3 下有所不同。例如，`HGETALL` 在 RESP2 中返回一个扁平化的键值对列表，而在 RESP3 中则可能返回一个 Map 类型，提供更加结构化的数据表示。

选择使用 RESP2 还是 RESP3 主要取决于你的应用需求以及你使用的客户端库是否支持 RESP3。如果你的应用能够从 RESP3 新增的数据类型或特性中受益，那么升级到 RESP3 可能是一个不错的选择。不过，需要注意的是，为了充分利用 RESP3 的优势，确保你的 Redis 客户端也支持该协议版本。

### 参考

https://redis.readthedocs.io/en/stable/examples/asyncio_examples.html